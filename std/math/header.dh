namespace math {
  func sin(x:f32):f32;
  func cos(x:f32):f32;
  func random():f32;
  func abs(x:f32):f32;
  func floor(x:f32):f32;
  func ceil(x:f32):f32;
  func round(x:f32):f32;
  func min(x:f32,y:f32):f32;
  func max(x:f32,y:f32):f32;
  func atan2(x:f32,y:f32):f32;
  func acos(x:f32):f32;
  func exp(x:f32):f32;
  func hypot(x:f32,y:f32):f32;
  PI : f32 = 3.141592653589793;
  func sin[N](x:vec[f32,N]):vec[f32,N]{return x.map(sin);};
  func cos[N](x:vec[f32,N]):vec[f32,N]{return x.map(cos);};
  func acos[N](x:vec[f32,N]):vec[f32,N]{return x.map(acos);};
  func exp[N](x:vec[f32,N]):vec[f32,N]{return x.map(exp);};
  func abs[N](x:vec[f32,N]):vec[f32,N]{return x.map(abs);};
  func floor[N](x:vec[f32,N]):vec[f32,N]{return x.map(floor);};
  func ceil[N](x:vec[f32,N]):vec[f32,N]{return x.map(ceil);};
  func round[N](x:vec[f32,N]):vec[f32,N]{return x.map(round);};
  func min[N](x:vec[f32,N],y:vec[f32,N]):vec[f32,N]{
    return x.map(func(a:f32,i:i32):f32{return min(a,y[i]);});
  };
  func max[N](x:vec[f32,N],y:vec[f32,N]):vec[f32,N]{
    return x.map(func(a:f32,i:i32):f32{return max(a,y[i]);});
  };
  func atan2[N](x:vec[f32,N],y:vec[f32,N]):vec[f32,N]{
    return x.map(func(a:f32,i:i32):f32{return atan2(a,y[i]);});
  };
  func hypot[N](x:vec[f32,N],y:vec[f32,N]):vec[f32,N]{
    return x.map(func(a:f32,i:i32):f32{return hypot(a,y[i]);});
  };
  func lerp[T](x:T,y:T,t:f32):T{
    return x*(1-t)+y*t;
  }
  func clamp[T](x:T, a:T, b:T):T{
    return min(max(x,a),b);
  }
  func linmap[T](x:T, ilo:T, ihi:T, olo:T, ohi:T):T{
    return olo + (ohi - olo) * ((x - ilo) / (ihi - ilo));
  }
}
