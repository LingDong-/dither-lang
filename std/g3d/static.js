globalThis.$g3d = new function(){
  const DIRTY_VERTICES = 1 ;
  const DIRTY_INDICES  = 2 ;
  const DIRTY_COLORS   = 4 ;
  const DIRTY_UVS      = 8 ;
  const DIRTY_NORMALS  = 16;

  let that = this;
  let cnv;
  let gl;
  let shader;
  let currentProgram = null;
  const vertexSrc = `
precision mediump float;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_uv;
attribute vec3 a_normal;
varying vec4 v_color;
varying vec2 v_uv;
varying vec3 v_normal;
varying vec3 v_position;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform mat3 normal_matrix;
void main() {
  v_color = a_color;
  v_uv = a_uv;
  v_normal = normalize(normal_matrix * a_normal);
  vec4 world_pos = model * vec4(a_position, 1.0);
  vec4 view_pos = view * world_pos;
  v_position = world_pos.xyz/world_pos.w;
  gl_Position = projection * view_pos;
}
  `;
  const fragmentSrc = `
precision mediump float;
varying vec4 v_color;
varying vec2 v_uv;
varying vec3 v_normal;
void main() {
  gl_FragColor = v_color;
}
  `;
  let vaos = [];
  let index_cons = Uint16Array;
  let index_type = 5123;//gl.UNSIGNED_SHORT;
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  that.init = function(){
    let [_] = $pop_args(1);
    cnv = document.getElementById("canvas");
    gl = cnv.getContext('webgl');

    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSrc);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);
    shader = gl.createProgram();
    gl.attachShader(shader, vertexShader);
    gl.attachShader(shader, fragmentShader);
    gl.linkProgram(shader);

    gl.enable(gl.DEPTH_TEST);
    gl.enable( gl.BLEND );
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    let ext = gl.getExtension('OES_element_index_uint');
    if (ext){
      index_type = gl.UNSIGNED_INT;
      index_cons = Uint32Array;
    }
  }
  function copy_list_vec_pack(lst,vn){
    let data = new Float32Array(lst.length*vn);
    for (let i = 0; i < lst.length; i++){
      for (let j = 0; j < vn; j++){
        data[i*vn+j] = lst[i][j];
      }
    }
    return data;
  }

  that._update_mesh = function(){
    let [vao,flags,vertices,indices,colors,uvs,normals] = $pop_args(7);
    let p_vertices, p_colors, p_uvs, p_normals;
    if (flags & DIRTY_VERTICES) p_vertices = copy_list_vec_pack(vertices,3);
    if (flags & DIRTY_COLORS) p_colors = copy_list_vec_pack(colors,4);
    if (flags & DIRTY_UVS) p_uvs = copy_list_vec_pack(uvs,2);
    if (flags & DIRTY_NORMALS) p_normals = copy_list_vec_pack(normals,3);

    let mesh;
    if (vao == -1){
      mesh = {
        vbo_vertices:gl.createBuffer(),
        vbo_colors:gl.createBuffer(),
        vbo_uvs:gl.createBuffer(),
        vbo_normals:gl.createBuffer(),
        ebo_indices:gl.createBuffer(),
      }
      // let dummy = new Float32Array(8);
      // gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_uvs);
      // gl.bufferData(gl.ARRAY_BUFFER, dummy, gl.STATIC_DRAW);

      vao = vaos.length;
      vaos.push(mesh);
    }else{
      mesh = vaos[vao];
    }
    if ((flags & DIRTY_VERTICES) && vertices.length){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_vertices);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(p_vertices), gl.STATIC_DRAW);
    }
    if ((flags & DIRTY_INDICES) && indices.length){
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ebo_indices);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new index_cons(indices), gl.STATIC_DRAW);
    }
    if ((flags & DIRTY_COLORS) && colors.length){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_colors);
      gl.bufferData(gl.ARRAY_BUFFER, p_colors, gl.STATIC_DRAW);
    }
    if ((flags & DIRTY_UVS) && uvs.length){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_uvs);
      gl.bufferData(gl.ARRAY_BUFFER, p_uvs, gl.STATIC_DRAW);
    }
    if ((flags & DIRTY_NORMALS) && normals.length){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_normals);
      gl.bufferData(gl.ARRAY_BUFFER, p_normals, gl.STATIC_DRAW);
    }
    vaos[vao].n_vertices = vertices.length;
    vaos[vao].n_indices = indices.length;
    vaos[vao].n_normals = normals.length;
    vaos[vao].n_uvs = uvs.length;
    vaos[vao].n_colors = colors.length;
    return vao;
  }
  function compute_normal_mat(modelMatrix) {
    let m = [
      modelMatrix[0], modelMatrix[4], modelMatrix[8],
      modelMatrix[1], modelMatrix[5], modelMatrix[9],
      modelMatrix[2], modelMatrix[6], modelMatrix[10],
    ];
    let a00 = m[0], a01 = m[3], a02 = m[6];
    let a10 = m[1], a11 = m[4], a12 = m[7];
    let a20 = m[2], a21 = m[5], a22 = m[8];
    let b01 = a22 * a11 - a12 * a21;
    let b11 = -a22 * a10 + a12 * a20;
    let b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (Math.abs(det) < Number.EPSILON){
      return new Float32Array(m);
    }
    let invDet = 1.0 / det;
    let out = new Float32Array(9);
    out[0] = b01 * invDet;
    out[1] = (-a22 * a01 + a02 * a21) * invDet;
    out[2] = (a12 * a01 - a02 * a11) * invDet;
    out[3] = b11 * invDet;
    out[4] = (a22 * a00 - a02 * a20) * invDet;
    out[5] = (-a12 * a00 + a02 * a10) * invDet;
    out[6] = b21 * invDet;
    out[7] = (-a21 * a00 + a01 * a20) * invDet;
    out[8] = (a11 * a00 - a01 * a10) * invDet;
    return out;
  }
  function glUniformMatrix4fv(loc,transpose,m){
    if (transpose) {
      m = new Float32Array([
        m[0], m[4], m[8],  m[12],
        m[1], m[5], m[9],  m[13],
        m[2], m[6], m[10], m[14],
        m[3], m[7], m[11], m[15],
      ]);
    }
    return gl.uniformMatrix4fv(loc, false, m);
  }
  that._draw_mesh = function(){
    let [vao,mode,model_matrix] = $pop_args(3);
    let mesh = vaos[vao];
    let program = gl.getParameter(gl.CURRENT_PROGRAM);

    let loc_model = gl.getUniformLocation(program, "model");
    glUniformMatrix4fv(loc_model, true, model_matrix);

    let nm = compute_normal_mat(model_matrix);
    let loc_nm = gl.getUniformLocation(program, "normal_matrix");
    gl.uniformMatrix3fv(loc_nm, false, nm);
    
    let loc_uv = gl.getAttribLocation(program, "a_uv");
    if (mesh.n_uvs){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_uvs);
      gl.enableVertexAttribArray(loc_uv);
      gl.vertexAttribPointer(loc_uv, 2, gl.FLOAT, false, 0, 0);
    }else{
      gl.disableVertexAttribArray(loc_uv);
      gl.vertexAttrib2f(loc_uv, 0.0, 0.0);
    }

    let loc_color = gl.getAttribLocation(program, "a_color");
    if (mesh.n_colors){
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_colors);
      gl.enableVertexAttribArray(loc_color);
      gl.vertexAttribPointer(loc_color, 4, gl.FLOAT, false, 0, 0);
    }else{
      gl.disableVertexAttribArray(loc_color);
      gl.vertexAttrib4f(loc_color, 1.0, 1.0, 1.0, 1.0);
    }
    
    let loc_norm = gl.getAttribLocation(program, "a_normal");
    if (loc_norm >= 0) {
      if (mesh.n_normals){
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_normals);
        gl.enableVertexAttribArray(loc_norm);
        gl.vertexAttribPointer(loc_norm, 3, gl.FLOAT, false, 0, 0);
      }else{
        gl.disableVertexAttribArray(loc_norm);
        gl.vertexAttrib3f(loc_norm, 0.0, 0.0, 1.0);
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo_vertices);
    let loc_pos = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(loc_pos);
    gl.vertexAttribPointer(loc_pos, 3, gl.FLOAT, false, 0, 0);

    if (mesh.n_indices){
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ebo_indices);
      gl.drawElements(mode,mesh.n_indices,index_type,0);
    }else{
      gl.drawArrays(mode,0,mesh.n_vertices);
    }
    if (loc_pos>=0)   gl.disableVertexAttribArray(loc_pos);
    if (loc_norm>=0)  gl.disableVertexAttribArray(loc_norm);
    if (loc_uv>=0)    gl.disableVertexAttribArray(loc_uv);
    if (loc_color>=0) gl.disableVertexAttribArray(loc_color);

  }


  that._look_at = function(){
    let [eye,center,up] = $pop_args(3);
    let f = [ center[0]-eye[0], center[1]-eye[1], center[2]-eye[2] ];
    let fn = Math.sqrt(f[0]*f[0] + f[1]*f[1] + f[2]*f[2]);
    for (let i = 0; i < 3; ++i) f[i] /= fn;
    let s = [
      f[1]*up[2] - f[2]*up[1],
      f[2]*up[0] - f[0]*up[2],
      f[0]*up[1] - f[1]*up[0]
    ];
    let sn = Math.sqrt(s[0]*s[0] + s[1]*s[1] + s[2]*s[2]);
    for (let i = 0; i < 3; ++i) s[i] /= sn;
    let u = [
      s[1]*f[2] - s[2]*f[1],
      s[2]*f[0] - s[0]*f[2],
      s[0]*f[1] - s[1]*f[0]
    ];
    let out = new Float32Array(16);
    out[0] = out[5] = out[10] = out[15] = 1;

    out[0 ] = s[0];
    out[1 ] = s[1];
    out[2 ] = s[2];
    out[4 ] = u[0];
    out[5 ] = u[1];
    out[6 ] = u[2];
    out[8 ] =-f[0];
    out[9 ] =-f[1];
    out[10] =-f[2];
    out[3 ] =-(s[0]*eye[0]+s[1]*eye[1]+s[2]*eye[2]);
    out[7 ] =-(u[0]*eye[0]+u[1]*eye[1]+u[2]*eye[2]);
    out[11] = (f[0]*eye[0]+f[1]*eye[1]+f[2]*eye[2]);
    return out;
  }
  that._perspective = function(){
    let [fov,aspect,nearZ,farZ] = $pop_args(4);
    fov = fov * Math.PI/180.0;
    let tanHalfFov = Math.tan(fov / 2.0);
    let out = new Float32Array(16);
    out[0]  = 1.0 / (tanHalfFov * aspect);
    out[5]  = 1.0 / tanHalfFov;
    out[10] = - (farZ+nearZ) / (farZ-nearZ);
    out[14] = - 1.0;
    out[11] = -(2.0 * farZ * nearZ) / (farZ-nearZ);
    return out;
  }
  that._ortho = function(){
    let [left,right,bottom,top,nearZ,farZ] = $pop_args(6);
    let rl = 1.0 / (right - left);
    let tb = 1.0 / (top - bottom);
    let fn = 1.0 / (farZ - nearZ);
    let out = new Float32Array(16);
    out[0]  = 2.0 * rl;
    out[5]  = 2.0 * tb;
    out[10] = -2.0 * fn;
    out[3] = -(right + left) * rl;
    out[7] = -(top + bottom) * tb;
    out[11] = -(farZ + nearZ) * fn;
    out[15] = 1.0;
    return out;
  }
  that.background = function(){
    let [r,g,b,a] = $pop_args(4);
    gl.clearColor(r,g,b,a);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  }
  let cached_view = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  let cached_proj = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  that._camera_begin = function(){
    let [view,proj] = $pop_args(2);
    currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    if (currentProgram === null){
      gl.useProgram(shader);
    }
    let program = gl.getParameter(gl.CURRENT_PROGRAM);
    glUniformMatrix4fv(
      gl.getUniformLocation(program,"view"),true,view
    );
    glUniformMatrix4fv(
      gl.getUniformLocation(program,"projection"),true,proj
    );
    cached_view = view;
    cached_proj = proj;
  }
  that._camera_end = function(){
    if (!currentProgram){
      gl.useProgram(null);
    }
    currentProgram = null;
  }
  that.mat = {
    rotate_deg: function(){
      let [axis,ang] = $pop_args(2);
      ang = ang * Math.PI/180.0;
      let x = axis[0], y = axis[1], z = axis[2];
      let len = Math.sqrt(x * x + y * y + z * z);
      let out = new Float32Array(16);
      if (len == 0.0) {
        for (let i = 0; i < 16; ++i)
          out[i] = (i % 5 == 0) ? 1 : 0;
        return;
      }
      x /= len;
      y /= len;
      z /= len;
      let c = Math.cos(ang);
      let s = Math.sin(ang);
      let t = 1.0 - c;
      out[0 ] = t*x*x + c;
      out[4 ] = t*x*y + s*z;
      out[8 ] = t*x*z - s*y;
      out[12] = 0.0;
      out[1 ] = t*x*y - s*z;
      out[5 ] = t*y*y + c;
      out[9 ] = t*y*z + s*x;
      out[13] = 0.0;
      out[2 ] = t*x*z + s*y;
      out[6 ] = t*y*z - s*x;
      out[10] = t*z*z + c;
      out[14] = 0.0;
      out[3 ] = 0.0;
      out[7 ] = 0.0;
      out[11] = 0.0;
      out[15] = 1.0;
      return out;
    }
  }
  that.flush = function(){

  }
  
  let FONT_W = 8;
  let FONT_H = 16;
  let FONT_COLS = 16;
  let FONT_ROWS = 8;
  let FONT_N = 128;
  let FONT_TEX_W = (FONT_COLS * FONT_W);
  let FONT_TEX_H = (FONT_ROWS * FONT_H);
  let font_texture = -1;
  let text_vbo = 0;
  let text_uv_vbo = 0;
  let text_shader = 0;
  let font_bitmap = new Uint8Array([
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x08,0x00,0x00,
    0x00,0x00,0x22,0x22,0x22,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x12,0x12,0x12,0x7E,0x24,0x24,0x7E,0x48,0x48,0x48,0x00,0x00,
    0x00,0x00,0x00,0x00,0x08,0x3E,0x49,0x48,0x38,0x0E,0x09,0x49,0x3E,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x31,0x4A,0x4A,0x34,0x08,0x08,0x16,0x29,0x29,0x46,0x00,0x00,
    0x00,0x00,0x00,0x00,0x1C,0x22,0x22,0x14,0x18,0x29,0x45,0x42,0x46,0x39,0x00,0x00,
    0x00,0x00,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x00,
    0x00,0x00,0x00,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x49,0x2A,0x1C,0x2A,0x49,0x08,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x08,0x08,0x10,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,
    0x00,0x00,0x00,0x00,0x02,0x02,0x04,0x08,0x08,0x10,0x10,0x20,0x40,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x18,0x24,0x42,0x46,0x4A,0x52,0x62,0x42,0x24,0x18,0x00,0x00,
    0x00,0x00,0x00,0x00,0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x0C,0x10,0x20,0x40,0x40,0x7E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x1C,0x02,0x02,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x44,0x44,0x7E,0x04,0x04,0x04,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x02,0x02,0x02,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x1C,0x20,0x40,0x40,0x7C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7E,0x02,0x02,0x04,0x04,0x04,0x08,0x08,0x08,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3E,0x02,0x02,0x02,0x04,0x38,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x08,0x08,0x10,0x00,
    0x00,0x00,0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x04,0x08,0x08,0x00,0x08,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x1C,0x22,0x4A,0x56,0x52,0x52,0x52,0x4E,0x20,0x1E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x18,0x24,0x24,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x42,0x42,0x42,0x42,0x7C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x40,0x40,0x40,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x78,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0x78,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x40,0x40,0x40,0x40,0x7E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x40,0x4E,0x42,0x42,0x46,0x3A,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x44,0x38,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x44,0x48,0x50,0x60,0x60,0x50,0x48,0x44,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x42,0x66,0x66,0x5A,0x5A,0x42,0x42,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x62,0x62,0x52,0x52,0x4A,0x4A,0x46,0x46,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x5A,0x66,0x3C,0x03,0x00,
    0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x48,0x44,0x44,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x30,0x0C,0x02,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x41,0x41,0x41,0x22,0x22,0x22,0x14,0x14,0x08,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x5A,0x5A,0x66,0x66,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x42,0x42,0x24,0x24,0x18,0x18,0x24,0x24,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x41,0x41,0x22,0x22,0x14,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
    0x00,0x00,0x00,0x00,0x7E,0x02,0x02,0x04,0x08,0x10,0x20,0x40,0x40,0x7E,0x00,0x00,
    0x00,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0E,0x00,
    0x00,0x00,0x00,0x00,0x40,0x40,0x20,0x10,0x10,0x08,0x08,0x04,0x02,0x02,0x00,0x00,
    0x00,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x70,0x00,
    0x00,0x00,0x18,0x24,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,
    0x00,0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x02,0x3E,0x42,0x42,0x46,0x3A,0x00,0x00,
    0x00,0x00,0x00,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x40,0x40,0x40,0x40,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x02,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x7E,0x40,0x40,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x0C,0x10,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x02,0x3A,0x44,0x44,0x44,0x38,0x20,0x3C,0x42,0x42,0x3C,
    0x00,0x00,0x00,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x08,0x08,0x00,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
    0x00,0x00,0x00,0x04,0x04,0x00,0x0C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x48,0x30,
    0x00,0x00,0x00,0x40,0x40,0x40,0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x42,0x00,0x00,
    0x00,0x00,0x00,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C,0x40,0x40,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x02,0x02,
    0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x40,0x30,0x0C,0x02,0x42,0x3C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x46,0x3A,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x49,0x49,0x49,0x49,0x49,0x49,0x36,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x24,0x18,0x18,0x24,0x42,0x42,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x3C,
    0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x02,0x04,0x08,0x10,0x20,0x40,0x7E,0x00,0x00,
    0x00,0x00,0x00,0x0C,0x10,0x10,0x08,0x08,0x10,0x20,0x10,0x08,0x08,0x10,0x10,0x0C,
    0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
    0x00,0x00,0x00,0x30,0x08,0x08,0x10,0x10,0x08,0x04,0x08,0x10,0x10,0x08,0x08,0x30,
    0x00,0x00,0x00,0x31,0x49,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  ]);
  const text_vertex_src = `precision mediump float;
    attribute vec3 a_position;
    attribute vec2 a_uv;
    varying vec2 v_uv;
    uniform mat4 model;
    uniform mat4 view;
    uniform mat4 projection;
    void main() {
      v_uv = a_uv;
      vec4 p = projection * view * model * vec4(a_position, 1.0);
      gl_Position = p;
    }`;

  const text_fragment_src = `precision mediump float;
    varying vec2 v_uv;
    uniform sampler2D font_atlas;
    void main() {
      gl_FragColor = texture2D(font_atlas,v_uv);
    }`;
  function build_font_texture() {
    let tex_data = new Uint8Array(FONT_TEX_H*FONT_TEX_W);
    for (let ch = 0; ch < FONT_N; ++ch) {
      let gx = (ch % FONT_COLS) * FONT_W;
      let gy = (ch / FONT_COLS) * FONT_H;
      for (let row = 0; row < FONT_H; ++row) {
        let bits = font_bitmap[ch*FONT_H+row];
        for (let col = 0; col < FONT_W; ++col) {
          if (bits & (1 << (7 - col))) {
            tex_data[ (gy + row) * FONT_TEX_W + gx + col] = 255;
          }
        }
      }
    }
    font_texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, font_texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, FONT_TEX_W, FONT_TEX_H, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, tex_data);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    text_vbo = gl.createBuffer();
    text_uv_vbo = gl.createBuffer();

    const vertexShader = compileShader(gl.VERTEX_SHADER, text_vertex_src);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, text_fragment_src);
    text_shader = gl.createProgram();
    gl.attachShader(text_shader, vertexShader);
    gl.attachShader(text_shader, fragmentShader);
    gl.linkProgram(text_shader);

  }

  that.text = function(){
    let [str,model_matrix] = $pop_args(2);
    if (font_texture == -1){
      build_font_texture();
    }
    let prev_prog = gl.getParameter(gl.CURRENT_PROGRAM);;
    let program = 0;
    if (prev_prog == 0 || prev_prog == shader){
      gl.useProgram(text_shader);
      program = text_shader;
      let loc_view = gl.getUniformLocation(program, "view");
      glUniformMatrix4fv(loc_view, true, cached_view);
      let loc_proj = gl.getUniformLocation(program, "projection");
      glUniformMatrix4fv(loc_proj, true, cached_proj);
    }else{
      program = prev_prog;
    }
    
 
    let loc_model = gl.getUniformLocation(program,"model");
    glUniformMatrix4fv(loc_model,true,model_matrix);

    let len = str.length;
    let vertices = new Float32Array(len*18);
    let uvs = new Float32Array(len*12);
    for (let i = 0; i < len; i++){
      let ch = str.charCodeAt(i)-32;
      let cx = ch % FONT_COLS;
      let cy = ch / FONT_COLS;
      let u0 = cx * (FONT_W / FONT_TEX_W);
      let v0 = cy * (FONT_H / FONT_TEX_H);
      let u1 = u0 + (FONT_W / FONT_TEX_W);
      let v1 = v0 + (FONT_H / FONT_TEX_H);
      let x0 = i * FONT_W;
      let y0 = 0;
      let x1 = x0 + FONT_W;
      let y1 = y0 + FONT_H;
      vertices[i*18+0]=x0;vertices[i*18+1]=y0;vertices[i*18+2]=0;
      vertices[i*18+3]=x1;vertices[i*18+4]=y0;vertices[i*18+5]=0;
      vertices[i*18+6]=x1;vertices[i*18+7]=y1;vertices[i*18+8]=0;
      vertices[i*18+9]=x0;vertices[i*18+10]=y0;vertices[i*18+11]=0;
      vertices[i*18+12]=x1;vertices[i*18+13]=y1;vertices[i*18+14]=0;
      vertices[i*18+15]=x0;vertices[i*18+16]=y1;vertices[i*18+17]=0;
      uvs[i*12+0]=u0;uvs[i*12+1]=v0;
      uvs[i*12+2]=u1;uvs[i*12+3]=v0;
      uvs[i*12+4]=u1;uvs[i*12+5]=v1;
      uvs[i*12+6]=u0;uvs[i*12+7]=v0;
      uvs[i*12+8]=u1;uvs[i*12+9]=v1;
      uvs[i*12+10]=u0;uvs[i*12+11]=v1;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, text_vbo);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, text_uv_vbo);
    gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.DYNAMIC_DRAW);

    let loc_uv = gl.getAttribLocation(program, "a_uv");
    gl.bindBuffer(gl.ARRAY_BUFFER, text_uv_vbo);
    gl.enableVertexAttribArray(loc_uv);
    gl.vertexAttribPointer(loc_uv, 2, gl.FLOAT, false, 0, 0);

    let loc_pos = gl.getAttribLocation(program, "a_position");
    gl.bindBuffer(gl.ARRAY_BUFFER, text_vbo);
    gl.enableVertexAttribArray(loc_pos);
    gl.vertexAttribPointer(loc_pos, 3, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, font_texture);
    let tex_loc = gl.getUniformLocation(program, "font_atlas");
    gl.uniform1i(tex_loc, 0);
    gl.drawArrays(gl.TRIANGLES, 0, len*6);

    gl.disableVertexAttribArray(loc_uv);
    gl.disableVertexAttribArray(loc_pos);

    gl.useProgram(prev_prog);

  }
}
