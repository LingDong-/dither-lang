#define _USE_MATH_DEFINES
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <float.h>

#ifdef __APPLE__
#define GL_SILENCE_DEPRECATION
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#elif defined(_WIN32)
#include <gl/GL.h>
#include <gl/GLU.h>
#pragma comment(lib, "opengl32.lib")
#include "../win/platform/wgl_patcher.h"
#else
#include <GL/glew.h>
#include <GL/gl.h>
//#include <GL/glext.h>
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif
#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#undef ARR_DEF
#define ARR_DEF(dtype) \
  typedef struct { int len; int cap; dtype* data; } dtype ## _arr_t;

#undef ARR_INIT
#define ARR_INIT(dtype,name) \
  name.len = 0;  \
  name.cap = 8; \
  name.data = (dtype*) malloc((name.cap)*sizeof(dtype));

#undef ARR_PUSH
#undef ARR_ITEM_FORCE_CAST
#ifdef _WIN32
#define ARR_ITEM_FORCE_CAST(dtype,item) item
#else
#define ARR_ITEM_FORCE_CAST(dtype,item) (dtype)item
#endif
#define ARR_PUSH(dtype,name,item) \
  if (name.cap < name.len+1){ \
    int hs = name.cap/2; \
    name.cap = name.len+MAX(1,hs); \
    name.data = (dtype*)realloc(name.data, (name.cap)*sizeof(dtype) ); \
  }\
  name.data[name.len] = ARR_ITEM_FORCE_CAST(dtype,item);\
  name.len += 1;

#undef ARR_POP
#define ARR_POP(dtype,name) (name.data[--name.len])

#undef ARR_CLEAR
#define ARR_CLEAR(dtype,name) {name.len = 0;}

#define DIRTY_VERTICES 1
#define DIRTY_INDICES  2
#define DIRTY_COLORS   4
#define DIRTY_UVS      8
#define DIRTY_NORMALS  16

GLint fbo_zero;

typedef struct vao_st {
  GLuint vbo_vertices;
  GLuint vbo_colors;
  GLuint vbo_uvs;
  GLuint vbo_normals;
  GLuint ebo_indices;
  int n_vertices;
  int n_colors;
  int n_uvs;
  int n_normals;
  int n_indices;
} vao_t;


ARR_DEF(vao_t);
vao_t_arr_t vaos;

GLuint shader = 0;

const char* vertex_src = "#version 120\n"
"attribute vec3 a_position;\n"
"attribute vec4 a_color;\n"
"attribute vec2 a_uv;\n"
"attribute vec3 a_normal;\n"
"varying vec4 v_color;\n"
"varying vec2 v_uv;\n"
"varying vec3 v_normal;\n"
"varying vec3 v_position;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"uniform mat3 normal_matrix;\n"
"void main() {\n"
"  v_color = a_color;\n"
"  v_uv = a_uv;\n"
"  v_normal = normalize(normal_matrix * a_normal);\n"
"  vec4 world_pos = model * vec4(a_position, 1.0);\n"
"  vec4 view_pos = view * world_pos;\n"
"  v_position = world_pos.xyz/world_pos.w;\n"
"  gl_Position = projection * view_pos;\n"
"}\n";

const char* fragment_src = "#version 120\n"
"varying vec4 v_color;\n"
"varying vec2 v_uv;\n"
"varying vec3 v_normal;\n"
"void main() {\n"
"  gl_FragColor = v_color;\n"
"}\n";

void checkCompileError(GLuint shader, const char* type) {
  GLint success;
  char infoLog[512];
  if (strcmp(type, "PROGRAM") != 0) {
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
      glGetShaderInfoLog(shader, 512, NULL, infoLog);
      printf("%s Shader compilation error:\n%s\n", type, infoLog);
    }
  } else {
    glGetProgramiv(shader, GL_LINK_STATUS, &success);
    if (!success) {
      glGetProgramInfoLog(shader, 512, NULL, infoLog);
      printf("Program linking error:\n%s\n", infoLog);
    }
  }
}

int compileShader(const char* vertex_src, const char* fragment_src){
  GLuint shaderProgram;
  GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
  glShaderSource(vertexShader, 1, &vertex_src, NULL);
  glCompileShader(vertexShader);
  checkCompileError(vertexShader, "VERTEX");
  GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
  glShaderSource(fragmentShader, 1, &fragment_src, NULL);
  glCompileShader(fragmentShader);
  checkCompileError(fragmentShader, "FRAGMENT");
  shaderProgram = glCreateProgram();
  glAttachShader(shaderProgram, vertexShader);
  glAttachShader(shaderProgram, fragmentShader);
  glLinkProgram(shaderProgram);
  checkCompileError(shaderProgram, "PROGRAM");
  glDeleteShader(vertexShader);
  glDeleteShader(fragmentShader);
  return shaderProgram;
}

void g3d_impl_init(uint64_t ctx){
  #ifndef __APPLE__
  glewInit();
  #endif
  glGetIntegerv(GL_FRAMEBUFFER_BINDING, &fbo_zero);
  ARR_INIT(vao_t,vaos);
  shader = compileShader(vertex_src,fragment_src);
  glEnable(GL_DEPTH_TEST);
  glEnable( GL_BLEND );
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

}

void g3d_impl_flush(){

  
}

void g3d_impl_background(float r, float g, float b, float a){
  glClearColor(r,g,b,a);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

int g3d_impl__update_mesh(int vao, int flags,
  float* vertices, int n_vertices,
  int32_t* indices, int n_indices,
  float* colors, int n_colors,
  float* uvs, int n_uvs,
  float* normals, int n_normals
){
  vao_t mesh;
  int need_push = 0;
  if (vao == -1) {
    glGenBuffers(1, &mesh.vbo_vertices);
    glGenBuffers(1, &mesh.vbo_colors);
    glGenBuffers(1, &mesh.vbo_uvs);

    float dummy[8] = {0};
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_uvs);
    glBufferData(GL_ARRAY_BUFFER,sizeof(float)*8,dummy,GL_STATIC_DRAW);

    glGenBuffers(1, &mesh.vbo_normals);
    glGenBuffers(1, &mesh.ebo_indices);
    need_push = 1;
  } else {
    mesh = vaos.data[vao];
  }


  if ((flags & DIRTY_VERTICES) && vertices && n_vertices > 0) {
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_vertices);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * n_vertices * 3, vertices, GL_STATIC_DRAW);
  }
  if ((flags & DIRTY_INDICES) && indices && n_indices > 0) {
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.ebo_indices);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(int32_t) * n_indices, indices, GL_STATIC_DRAW);
  }
  if ((flags & DIRTY_COLORS) && colors && n_colors > 0) {
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_colors);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * n_colors * 4, colors, GL_STATIC_DRAW);
  }
  if ((flags & DIRTY_UVS) && uvs && n_uvs > 0) {
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_uvs);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * n_uvs * 2, uvs, GL_STATIC_DRAW);
  }
  if ((flags & DIRTY_NORMALS) && normals && n_normals > 0) {
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_normals);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * n_normals * 3, normals, GL_STATIC_DRAW);
  }

  if (need_push){
    vao = vaos.len;
    ARR_PUSH(vao_t,vaos,mesh);
  }
  vaos.data[vao].n_vertices = n_vertices;
  vaos.data[vao].n_indices = n_indices;
  vaos.data[vao].n_normals = n_normals;
  vaos.data[vao].n_uvs = n_uvs;
  vaos.data[vao].n_colors = n_colors;


  return vao;
}

void g3d_impl__ortho(float* out, float left, float right, float bottom, float top, float nearZ, float farZ) {
  memset(out, 0, sizeof(float) * 16);
  float rl = 1.0f / (right - left);
  float tb = 1.0f / (top - bottom);
  float fn = 1.0f / (farZ - nearZ);
  out[0]  = 2.0f * rl;
  out[5]  = 2.0f * tb;
  out[10] = -2.0f * fn;
  out[3] = -(right + left) * rl;
  out[7] = -(top + bottom) * tb;
  out[11] = -(farZ + nearZ) * fn;
  out[15] = 1.0f;
}

void g3d_impl__perspective(float* out, float fov, float aspect, float nearZ, float farZ) {
  float tanHalfFov = tanf(fov / 2.0f);
  memset(out, 0, sizeof(float) * 16);
  out[0]  = 1.0f / (tanHalfFov * aspect);
  out[5]  = 1.0f / tanHalfFov;
  out[10] = - (farZ+nearZ) / (farZ-nearZ);
  out[14] = - 1.0f;
  out[11] = -(2.0f * farZ * nearZ) / (farZ-nearZ);
}

void g3d_impl__look_at(float* out, float* eye, float* center, float* up) {
  float f[3] = { center[0]-eye[0], center[1]-eye[1], center[2]-eye[2] };
  float fn = sqrtf(f[0]*f[0] + f[1]*f[1] + f[2]*f[2]);
  for (int i = 0; i < 3; ++i) f[i] /= fn;
  float s[3] = {
    f[1]*up[2] - f[2]*up[1],
    f[2]*up[0] - f[0]*up[2],
    f[0]*up[1] - f[1]*up[0]
  };
  float sn = sqrtf(s[0]*s[0] + s[1]*s[1] + s[2]*s[2]);
  for (int i = 0; i < 3; ++i) s[i] /= sn;
  float u[3] = {
    s[1]*f[2] - s[2]*f[1],
    s[2]*f[0] - s[0]*f[2],
    s[0]*f[1] - s[1]*f[0]
  };
  memset(out, 0, sizeof(float) * 16);
  out[0] = out[5] = out[10] = out[15] = 1;

  out[0 ] = s[0];
  out[1 ] = s[1];
  out[2 ] = s[2];
  out[4 ] = u[0];
  out[5 ] = u[1];
  out[6 ] = u[2];
  out[8 ] =-f[0];
  out[9 ] =-f[1];
  out[10] =-f[2];
  out[3 ] =-(s[0]*eye[0]+s[1]*eye[1]+s[2]*eye[2]);
  out[7 ] =-(u[0]*eye[0]+u[1]*eye[1]+u[2]*eye[2]);
  out[11] = (f[0]*eye[0]+f[1]*eye[1]+f[2]*eye[2]);

}

void g3d_mat_impl_rotate(float* out, float* axis, float ang){
  float x = axis[0], y = axis[1], z = axis[2];
  float len = sqrtf(x * x + y * y + z * z);
  if (len == 0.0f) {
    for (int i = 0; i < 16; ++i)
      out[i] = (i % 5 == 0) ? 1.0f : 0.0f;
    return;
  }
  x /= len;
  y /= len;
  z /= len;
  float c = cosf(ang);
  float s = sinf(ang);
  float t = 1.0f - c;
  out[0 ] = t*x*x + c;
  out[4 ] = t*x*y + s*z;
  out[8 ] = t*x*z - s*y;
  out[12] = 0.0f;
  out[1 ] = t*x*y - s*z;
  out[5 ] = t*y*y + c;
  out[9 ] = t*y*z + s*x;
  out[13]  = 0.0f;
  out[2 ] = t*x*z + s*y;
  out[6 ] = t*y*z - s*x;
  out[10] = t*z*z + c;
  out[14] = 0.0f;
  out[3 ] = 0.0f;
  out[7 ] = 0.0f;
  out[11] = 0.0f;
  out[15] = 1.0f;
}

void compute_normal_mat(float* out, const float* modelMatrix) {

  float m[9] = {
    modelMatrix[0], modelMatrix[4], modelMatrix[8],
    modelMatrix[1], modelMatrix[5], modelMatrix[9],
    modelMatrix[2], modelMatrix[6], modelMatrix[10],
  };
  float a00 = m[0], a01 = m[3], a02 = m[6];
  float a10 = m[1], a11 = m[4], a12 = m[7];
  float a20 = m[2], a21 = m[5], a22 = m[8];
  float b01 = a22 * a11 - a12 * a21;
  float b11 = -a22 * a10 + a12 * a20;
  float b21 = a21 * a10 - a11 * a20;
  float det = a00 * b01 + a01 * b11 + a02 * b21;
  if (fabsf(det) < FLT_EPSILON){
    memcpy(out,m,sizeof(m));
    return;
  }
  float invDet = 1.0f / det;
  out[0] = b01 * invDet;
  out[1] = (-a22 * a01 + a02 * a21) * invDet;
  out[2] = (a12 * a01 - a02 * a11) * invDet;
  out[3] = b11 * invDet;
  out[4] = (a22 * a00 - a02 * a20) * invDet;
  out[5] = (-a12 * a00 + a02 * a10) * invDet;
  out[6] = b21 * invDet;
  out[7] = (-a21 * a00 + a01 * a20) * invDet;
  out[8] = (a11 * a00 - a01 * a10) * invDet;
}
GLint currentProgram = 0;
float cached_view[16] = {1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1};
float cached_proj[16] = {1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1};
void g3d_impl__camera_begin(float* view, float* proj){

  glGetIntegerv(GL_CURRENT_PROGRAM, &currentProgram);
  if (!currentProgram){
    glUseProgram(shader);
  }
  GLint program = 0;
  glGetIntegerv(GL_CURRENT_PROGRAM, &program);
  GLint loc_view = glGetUniformLocation(program, "view");
  if (loc_view >= 0) glUniformMatrix4fv(loc_view, 1, GL_TRUE, view);
  GLint loc_proj = glGetUniformLocation(program, "projection");
  if (loc_proj >= 0) glUniformMatrix4fv(loc_proj, 1, GL_TRUE, proj);
  memcpy(cached_view,view,sizeof(cached_view));
  memcpy(cached_proj,proj,sizeof(cached_proj));
}

void g3d_impl__camera_end(){
  if (!currentProgram){
    glUseProgram(0);
  }
  currentProgram = 0;
}


void g3d_impl__draw_mesh(int vao, int mode, float* model_matrix) {

  vao_t mesh = vaos.data[vao];
  GLint program = 0;

  glGetIntegerv(GL_CURRENT_PROGRAM, &program);


  GLint loc_model = glGetUniformLocation(program, "model");
  if (loc_model >= 0) glUniformMatrix4fv(loc_model, 1, GL_TRUE, model_matrix);

  float nm[9] = {1,0,0, 0,1,0, 0,0,1};
  compute_normal_mat(nm,model_matrix);
  GLint loc_nm = glGetUniformLocation(program, "normal_matrix");
  if (loc_nm >= 0) glUniformMatrix3fv(loc_nm, 1, GL_FALSE, nm);

  
  GLint loc_uv = glGetAttribLocation(program, "a_uv");
  glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_uvs);
  glEnableVertexAttribArray(loc_uv);
  glVertexAttribPointer(loc_uv, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);

  GLint loc_color = glGetAttribLocation(program, "a_color");
  if (loc_color >= 0) {
    if (mesh.n_colors){
      glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_colors);
      glEnableVertexAttribArray(loc_color);
      glVertexAttribPointer(loc_color, 4, GL_FLOAT, GL_FALSE, 0, (void*)0);
    }else{
      glDisableVertexAttribArray(loc_color);
      glVertexAttrib4f(loc_color, 1.0f, 1.0f, 1.0f, 1.0f);
    }
  }
  GLint loc_norm = glGetAttribLocation(program, "a_normal");
  if (loc_norm >= 0) {
    if (mesh.n_normals){
      glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_normals);
      glEnableVertexAttribArray(loc_norm);
      glVertexAttribPointer(loc_norm, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
    }else{
      glDisableVertexAttribArray(loc_norm);
      glVertexAttrib3f(loc_norm, 0.0f, 0.0f, 1.0f);
    }
  }

  glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo_vertices);
  GLuint loc_pos = glGetAttribLocation(program, "a_position");
  glEnableVertexAttribArray(loc_pos);
  glVertexAttribPointer(loc_pos, 3, GL_FLOAT, GL_FALSE, 0, 0);


  if (mesh.n_indices){
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.ebo_indices);
    glDrawElements(mode,mesh.n_indices,GL_UNSIGNED_INT,(void*)0);
  }else{
    glDrawArrays(mode, 0, mesh.n_vertices);
  }
  if (loc_pos >= 0)   glDisableVertexAttribArray(loc_pos);
  if (loc_norm >= 0)  glDisableVertexAttribArray(loc_norm);
  if (loc_uv >= 0)    glDisableVertexAttribArray(loc_uv);
  if (loc_color >= 0) glDisableVertexAttribArray(loc_color);


}


#define FONT_W 8
#define FONT_H 16
#define FONT_COLS 16
#define FONT_ROWS 8
#define FONT_N 128
#define FONT_TEX_W (FONT_COLS * FONT_W)
#define FONT_TEX_H (FONT_ROWS * FONT_H)
GLuint font_texture = -1;
GLuint text_vbo = 0;
GLuint text_uv_vbo = 0;
GLuint text_shader = 0;

uint8_t font_bitmap[FONT_N*FONT_H] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x08,0x00,0x00,
  0x00,0x00,0x22,0x22,0x22,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x12,0x12,0x12,0x7E,0x24,0x24,0x7E,0x48,0x48,0x48,0x00,0x00,
  0x00,0x00,0x00,0x00,0x08,0x3E,0x49,0x48,0x38,0x0E,0x09,0x49,0x3E,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x31,0x4A,0x4A,0x34,0x08,0x08,0x16,0x29,0x29,0x46,0x00,0x00,
  0x00,0x00,0x00,0x00,0x1C,0x22,0x22,0x14,0x18,0x29,0x45,0x42,0x46,0x39,0x00,0x00,
  0x00,0x00,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x00,
  0x00,0x00,0x00,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x49,0x2A,0x1C,0x2A,0x49,0x08,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x08,0x08,0x10,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,
  0x00,0x00,0x00,0x00,0x02,0x02,0x04,0x08,0x08,0x10,0x10,0x20,0x40,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x18,0x24,0x42,0x46,0x4A,0x52,0x62,0x42,0x24,0x18,0x00,0x00,
  0x00,0x00,0x00,0x00,0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x0C,0x10,0x20,0x40,0x40,0x7E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x1C,0x02,0x02,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x44,0x44,0x7E,0x04,0x04,0x04,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x02,0x02,0x02,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x1C,0x20,0x40,0x40,0x7C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7E,0x02,0x02,0x04,0x04,0x04,0x08,0x08,0x08,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3C,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3E,0x02,0x02,0x02,0x04,0x38,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x08,0x08,0x10,0x00,
  0x00,0x00,0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x04,0x08,0x08,0x00,0x08,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x1C,0x22,0x4A,0x56,0x52,0x52,0x52,0x4E,0x20,0x1E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x18,0x24,0x24,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x42,0x42,0x42,0x42,0x7C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x40,0x40,0x40,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x78,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0x78,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x40,0x40,0x40,0x40,0x7E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x7C,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x40,0x4E,0x42,0x42,0x46,0x3A,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x44,0x38,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x44,0x48,0x50,0x60,0x60,0x50,0x48,0x44,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x66,0x66,0x5A,0x5A,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x62,0x62,0x52,0x52,0x4A,0x4A,0x46,0x46,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x5A,0x66,0x3C,0x03,0x00,
  0x00,0x00,0x00,0x00,0x7C,0x42,0x42,0x42,0x7C,0x48,0x44,0x44,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x30,0x0C,0x02,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x41,0x41,0x41,0x22,0x22,0x22,0x14,0x14,0x08,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x5A,0x5A,0x66,0x66,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x24,0x24,0x18,0x18,0x24,0x24,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x41,0x41,0x22,0x22,0x14,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
  0x00,0x00,0x00,0x00,0x7E,0x02,0x02,0x04,0x08,0x10,0x20,0x40,0x40,0x7E,0x00,0x00,
  0x00,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0E,0x00,
  0x00,0x00,0x00,0x00,0x40,0x40,0x20,0x10,0x10,0x08,0x08,0x04,0x02,0x02,0x00,0x00,
  0x00,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x70,0x00,
  0x00,0x00,0x18,0x24,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,
  0x00,0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x02,0x3E,0x42,0x42,0x46,0x3A,0x00,0x00,
  0x00,0x00,0x00,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x40,0x40,0x40,0x40,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x02,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x7E,0x40,0x40,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x0C,0x10,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x02,0x3A,0x44,0x44,0x44,0x38,0x20,0x3C,0x42,0x42,0x3C,
  0x00,0x00,0x00,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x08,0x08,0x00,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
  0x00,0x00,0x00,0x04,0x04,0x00,0x0C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x48,0x30,
  0x00,0x00,0x00,0x40,0x40,0x40,0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x42,0x00,0x00,
  0x00,0x00,0x00,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C,0x40,0x40,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x40,0x30,0x0C,0x02,0x42,0x3C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x46,0x3A,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x49,0x49,0x49,0x49,0x49,0x49,0x36,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x24,0x18,0x18,0x24,0x42,0x42,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x3C,
  0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x02,0x04,0x08,0x10,0x20,0x40,0x7E,0x00,0x00,
  0x00,0x00,0x00,0x0C,0x10,0x10,0x08,0x08,0x10,0x20,0x10,0x08,0x08,0x10,0x10,0x0C,
  0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x00,0x00,0x00,0x30,0x08,0x08,0x10,0x10,0x08,0x04,0x08,0x10,0x10,0x08,0x08,0x30,
  0x00,0x00,0x00,0x31,0x49,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const char* text_vertex_src = "#version 120\n"
"attribute vec3 a_position;\n"
"attribute vec2 a_uv;\n"
"varying vec2 v_uv;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"void main() {\n"
"  v_uv = a_uv;\n"
"  vec4 p = projection * view * model * vec4(a_position, 1.0);\n"
"  gl_Position = p;\n"
"}\n";

const char* text_fragment_src = "#version 120\n"
"varying vec2 v_uv;\n"
"uniform sampler2D font_atlas;\n"
"void main() {\n"
"  gl_FragColor = texture2D(font_atlas,v_uv);\n"
"}\n";

void build_font_texture() {
  unsigned char tex_data[FONT_TEX_H][FONT_TEX_W];
  memset(tex_data, 0, FONT_TEX_W*FONT_TEX_H);
  for (int ch = 0; ch < FONT_N; ++ch) {
    int gx = (ch % FONT_COLS) * FONT_W;
    int gy = (ch / FONT_COLS) * FONT_H;
    for (int row = 0; row < FONT_H; ++row) {
      uint8_t bits = font_bitmap[ch*FONT_H+row];
      for (int col = 0; col < FONT_W; ++col) {
        if (bits & (1 << (7 - col))) {
          tex_data[gy + row][gx + col] = 255;
        }
      }
    }
  }
  glGenTextures(1, &font_texture);
  glBindTexture(GL_TEXTURE_2D, font_texture);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, FONT_TEX_W, FONT_TEX_H, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, tex_data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

  glGenBuffers(1, &text_vbo);
  glGenBuffers(1, &text_uv_vbo);

  text_shader = compileShader(text_vertex_src,text_fragment_src);
}


void g3d_impl_text(char* str, float* model_matrix){
  if (font_texture == -1){
    build_font_texture();
  }
  GLint prev_prog = 0;
  GLint program = 0;


  glGetIntegerv(GL_CURRENT_PROGRAM, &prev_prog);

  if (prev_prog == 0 || prev_prog == shader){
    
    glUseProgram(text_shader);
    program = text_shader;
    GLint loc_view = glGetUniformLocation(program, "view");
    if (loc_view >= 0) glUniformMatrix4fv(loc_view, 1, GL_TRUE, cached_view);
    GLint loc_proj = glGetUniformLocation(program, "projection");
    if (loc_proj >= 0) glUniformMatrix4fv(loc_proj, 1, GL_TRUE, cached_proj);
  }else{
    program = prev_prog;
  }

  GLint loc_model = glGetUniformLocation(program, "model");
  glUniformMatrix4fv(loc_model, 1, GL_TRUE, model_matrix);

  int len = strlen(str);

  float* vertices = malloc(len*18*sizeof(float));
  float* uvs = malloc(len*12*sizeof(float));

  for (int i = 0; i < len; i++) {
    unsigned char ch = str[i]-' ';
    int cx = ch % FONT_COLS;
    int cy = ch / FONT_COLS;
    float u0 = cx * (FONT_W / (float)FONT_TEX_W);
    float v0 = cy * (FONT_H / (float)FONT_TEX_H);
    float u1 = u0 + (FONT_W / (float)FONT_TEX_W);
    float v1 = v0 + (FONT_H / (float)FONT_TEX_H);
    float x0 = i * FONT_W;
    float y0 = 0;
    float x1 = x0 + FONT_W;
    float y1 = y0 + FONT_H;
    vertices[i*18+0]=x0;vertices[i*18+1]=y0;vertices[i*18+2]=0;
    vertices[i*18+3]=x1;vertices[i*18+4]=y0;vertices[i*18+5]=0;
    vertices[i*18+6]=x1;vertices[i*18+7]=y1;vertices[i*18+8]=0;
    vertices[i*18+9]=x0;vertices[i*18+10]=y0;vertices[i*18+11]=0;
    vertices[i*18+12]=x1;vertices[i*18+13]=y1;vertices[i*18+14]=0;
    vertices[i*18+15]=x0;vertices[i*18+16]=y1;vertices[i*18+17]=0;
    uvs[i*12+0]=u0;uvs[i*12+1]=v0;
    uvs[i*12+2]=u1;uvs[i*12+3]=v0;
    uvs[i*12+4]=u1;uvs[i*12+5]=v1;
    uvs[i*12+6]=u0;uvs[i*12+7]=v0;
    uvs[i*12+8]=u1;uvs[i*12+9]=v1;
    uvs[i*12+10]=u0;uvs[i*12+11]=v1;
  }

  glBindBuffer(GL_ARRAY_BUFFER, text_vbo);
  glBufferData(GL_ARRAY_BUFFER, len*18*sizeof(float), vertices, GL_DYNAMIC_DRAW);
  // glBufferData(GL_ARRAY_BUFFER, len*18*sizeof(float), NULL, GL_DYNAMIC_DRAW);
  // glBufferSubData(GL_ARRAY_BUFFER, 0, len*18*sizeof(float), vertices);

  glBindBuffer(GL_ARRAY_BUFFER, text_uv_vbo);
  glBufferData(GL_ARRAY_BUFFER, len*12*sizeof(float), uvs, GL_DYNAMIC_DRAW);
  // glBufferData(GL_ARRAY_BUFFER, len*12*sizeof(float), NULL, GL_DYNAMIC_DRAW);
  // glBufferSubData(GL_ARRAY_BUFFER, 0, len*12*sizeof(float), uvs);

  GLint loc_uv = glGetAttribLocation(program, "a_uv");
  glBindBuffer(GL_ARRAY_BUFFER, text_uv_vbo);
  glEnableVertexAttribArray(loc_uv);
  glVertexAttribPointer(loc_uv, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);

  GLuint loc_pos = glGetAttribLocation(program, "a_position");
  glBindBuffer(GL_ARRAY_BUFFER, text_vbo);
  glEnableVertexAttribArray(loc_pos);
  glVertexAttribPointer(loc_pos, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, font_texture);
  GLint tex_loc = glGetUniformLocation(program, "font_atlas");
  glUniform1i(tex_loc, 0);
  glDrawArrays(GL_TRIANGLES, 0, len*6);

  glDisableVertexAttribArray(loc_uv);
  glDisableVertexAttribArray(loc_pos);

  free(vertices);
  free(uvs);

  glUseProgram(prev_prog);
}