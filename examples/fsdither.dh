include "std/math"
include "std/img"
include "std/io"
include "std/arr"
include "std/time"
include "std/gx"
include "std/guts"

// floyd-steinberg dither demo

nlvl := 2; // number of quantize levels
gray := 0; // do grayscale instead of color?
scl  := 2; // upscale to visualize

pixels := img.decode(io.read_file("examples/assets/pepper.png"));

({H,W,chan}) := pixels.shape();

fstein := arr.make({2,W+2},{0.,0.,0.});

func quant(x:f32):f32{
  return math.round(x*nlvl)/nlvl;
}

guts.gc_off();

swap := 0
next := {0.,0.,0.}
for (y:=0; y<H; y++){
  for (x:=0; x<W; x++){
    o := {pixels[y,x,gray] as f32,pixels[y,x,1],pixels[y,x,2-gray]}/255.0 
    o += next + fstein[1-swap,x+1];
    c := { quant(o.r), quant(o.g), quant(o.b) };
    err := o - c;
    
    ({pixels[y,x,0],pixels[y,x,1],pixels[y,x,2]}) = c*255;
    next = (err*7)/16;
    fstein[swap,x  ] += (err*3)/16;
    fstein[swap,x+1] += (err*5)/16;
    fstein[swap,x+2] += (err*1)/16;
  }
  swap = 1-swap;
  for (x:=0; x<W+2; x++){
    fstein[swap,x] = {0.,0.,0.};
  }
}

fstein.reshape({0,0});
guts.gc_on();

gx.size(W*scl,H*scl)

pg := gx.create_graphics(W,H);
pg.write_pixels(pixels);


while (1){
  gx.background(0);
  pg.draw(0,0,W*scl,H*scl);
  gx.poll();
}

