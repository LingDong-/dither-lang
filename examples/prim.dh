include "std/g3d"
include "std/win"
include "std/list"
include "std/vec"
include "std/frag"
include "std/time"
include "std/math"

namespace prim{

  typedef AbstractMesh = {
    vertices := list[vec[f32,3]]{};
    faces := list[list[i32]]{};
    normals := list[vec[f32,3]]{};
    func smooth():g3d.Mesh{
      mesh := g3d.Mesh{};
      for (i := 0; i < .vertices.length(); i++){
        mesh.vertices.push(.vertices[i]);
        mesh.normals.push(.normals[i]);
      }
      for (i := 0; i < .faces.length(); i++) {
        n := .faces[i].length();
        for (j := 0; j < n; j++){
          mesh.indices.push(.faces[i][0]);
          mesh.indices.push(.faces[i][j-1]);
          mesh.indices.push(.faces[i][j]);
        }
      }
      return mesh;
    }
    func faceted():g3d.Mesh{
      mesh := g3d.Mesh{};
      for (i := 0; i < .faces.length(); i++) {
        n := .faces[i].length();
        m := mesh.vertices.length();
        for (j := 0; j < n; j++) {
          p0 := .vertices[.faces[i][(j+n-1)%n]]
          p1 := .vertices[.faces[i][j]];
          p2 := .vertices[.faces[i][(j+1)%n]];
          nml := (p1-p0).cross(p2-p1).dir();
          mesh.vertices.push(p1);
          if (j>1){
            mesh.indices.push(m);
            mesh.indices.push(m + j-1);
            mesh.indices.push(m + j);
          }
          mesh.normals.push(nml);
        }
      }
      return mesh;
    }
    func wireframe(offset:f32):g3d.Mesh{
      mesh := g3d.Mesh{mode:g3d.MODE_LINE_LIST};
      edges := dict[vec[i32,2],i32]{}
      for (i := 0; i < .faces.length(); i++) {
        n := .faces[i].length();
        for (j := 0; j < n; j++) {
          ii := {.faces[i][j], .faces[i][(j+1)%n]};
          if (ii.x > ii.y){
            ii = ii.yx;
          }
          if (!edges[ii]){
            mesh.vertices.push(.vertices[ii.x]+.normals[ii.x]*offset);
            mesh.vertices.push(.vertices[ii.y]+.normals[ii.y]*offset);
            mesh.normals.push(.normals[ii.x]);
            mesh.normals.push(.normals[ii.y]);
            edges[ii] = 1;
          }
        }
      }
      return mesh;
    }
    func wireframe():g3d.Mesh{return .wireframe(0);};
  }

  func icosphere(order:i32):AbstractMesh{
    PHI := 1.618034 
    vertices := list[vec[f32,3]]{
      {-1,  PHI, 0}, { 1,  PHI, 0}, {-1, -PHI, 0}, { 1, -PHI, 0},
      {0, -1,  PHI}, {0,  1,  PHI}, {0, -1, -PHI}, {0,  1, -PHI},
      { PHI, 0, -1}, { PHI, 0,  1}, {-PHI, 0, -1}, {-PHI, 0,  1}
    };
    faces := list[i32]{
      0,11,5,  0, 5, 1,  0, 1, 7,  0,7,10,  0,10,11,
      1, 5,9,  5,11, 4, 11,10, 2, 10,7, 6,  7, 1, 8,
      3, 9,4,  3, 4, 2,  3, 2, 6,  3,6, 8,  3, 8, 9,
      4, 9,5,  2, 4,11,  6, 2,10,  8,6, 7,  9, 8, 1
    }
    mid_pts := dict[vec[i32,2],i32]{}
    func add_mid_pt(ii:vec[i32,2]):i32{
      if (ii.x > ii.y){
        ii = ii.yx;
      }
      if (mid_pts[ii]){
        return mid_pts[ii]-1;
      }
      vertices.push((vertices[ii.x]+vertices[ii.y])*0.5);
      mid_pts[ii] = vertices.length();
      return mid_pts[ii]-1;
    }
    for (iter:=0;iter<order;iter++){
      n := faces.length();
      for (i:=0; i<n;i+=3){
        a := faces[i];
        b := faces[i+1];
        c := faces[i+2];
        d := add_mid_pt({a,b});
        e := add_mid_pt({b,c});
        f := add_mid_pt({c,a});
        faces.push(b); faces.push(e); faces.push(d);
        faces.push(c); faces.push(f); faces.push(e);
        faces.push(d); faces.push(e); faces.push(f);
        faces[i+1] = d;
        faces[i+2] = f;
      }
    }
    normals := list[vec[f32,3]]{};
    for (i := 0; i < vertices.length(); i++){
      vertices[i] = vertices[i].dir();
      normals.push(vertices[i]);
    }
    mesh := AbstractMesh{vertices:vertices, normals:normals};
    for (i := 0; i < faces.length(); i+=3){
      face := list[i32]{faces[i],faces[i+1],faces[i+2]};
      mesh.faces.push(face);
    }
    return mesh;
  }

  func cube():AbstractMesh{
    vertices:=list[vec[f32,3]]{
      {-1.,-1.,-1.}, { 1.,-1.,-1.},
      { 1., 1.,-1.}, {-1., 1.,-1.},
      {-1.,-1., 1.}, { 1.,-1., 1.},
      { 1., 1., 1.}, {-1., 1., 1.}
    };
    faces:=list[list[i32]]{
      list[i32]{0,3,2,1}, list[i32]{4,5,6,7},
      list[i32]{0,4,7,3}, list[i32]{2,6,5,1},
      list[i32]{3,7,6,2}, list[i32]{0,1,5,4}
    };
    normals:=list[vec[f32,3]]{};
    for (i := 0; i < vertices.length(); i++){
      normals.push(vertices[i].dir());
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }
  func cylinder(sides:i32):AbstractMesh{
    vertices:=list[vec[f32,3]]{};
    faces:=list[list[i32]]{ list[i32]{}, list[i32]{} };
    normals:=list[vec[f32,3]]{};
    for (i := 0; i < sides; i++){
      a := i*math.PI*2./sides;
      x := math.cos(a);
      z := math.sin(a);
      vertices.push({x,-1,z});
      vertices.push({x,-1,z});
      vertices.push({x, 1,z});
      vertices.push({x, 1,z});
      normals.push({0,-1,0});
      normals.push({x,0,z});
      normals.push({0,1,0});
      normals.push({x,0,z});
      faces[0].push(i*4  );
      faces[1].insert(0,i*4+2);
      faces.push(list[i32]{i*4+1,i*4+3,((i+1)%sides)*4+3,((i+1)%sides)*4+1});
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }
  func cone(sides:i32):AbstractMesh{
    vertices:=list[vec[f32,3]]{};
    faces:=list[list[i32]]{ list[i32]{} };
    normals:=list[vec[f32,3]]{};
    for (i := 0; i < sides; i++){
      a := i*math.PI*2./sides;
      x := math.cos(a);
      z := math.sin(a);
      vertices.push({x,-1,z});
      vertices.push({x,-1,z});
      vertices.push({0, 1,0});

      normals.push({0,-1,0});
      
      nml := ({2*x,1,2*z}).dir();
      normals.push(nml);
      normals.push({0,1,0});

      faces[0].push(i*3);
      faces.push(list[i32]{i*3+1,i*3+2,((i+1)%sides)*3+1});
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }
  func uvsphere(m:i32,n:i32):AbstractMesh{
    vertices:=list[vec[f32,3]]{ {0.,1,0}, {0.,-1,0} };
    faces:=list[list[i32]]{};
    normals:=list[vec[f32,3]]{ {0.,1,0}, {0.,-1,0} };
    for (i := 0; i < m; i++){
      th := (i+0.5)*math.PI/m;
      sinth := math.sin(th);
      costh := math.cos(th);
      for (j := 0; j < n; j++){
        ph := j*math.PI*2./n;
        x := sinth*math.cos(ph);
        z := sinth*math.sin(ph);
        y := costh;
        vertices.push({x,y,z});
        normals.push({x,y,z});
        if (i<m-1){
          faces.push(list[i32]{ 2+i*n+j, 2+i*n+(j+1)%n, 2+(i+1)*n+(j+1)%n, 2+(i+1)*n+j  });
        }else{
          faces.push(list[i32]{ 2+i*n+j, 2+i*n+(j+1)%n , 1});
        }
        if (i==0){
          faces.push(list[i32]{ 2+i*n+j, 0, 2+i*n+(j+1)%n });
        }
      }
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }
  func torus(r:f32,m:i32,n:i32):AbstractMesh{
    vertices:=list[vec[f32,3]]{};
    faces:=list[list[i32]]{};
    normals:=list[vec[f32,3]]{};
    for (i := 0; i < m; i++){
      th := i*math.PI*2./m;
      costh := math.cos(th);
      sinth := math.sin(th);
      for (j := 0; j < n; j++){
        ph := j*math.PI*2./n;
        cosph := math.cos(ph);
        sinph := math.sin(ph);
        x := 1 + r*cosph;
        y := r*sinph;
        vertices.push({x*costh,y,x*sinth});
        faces.push(list[i32]{ i*n+j, i*n+(j+1)%n, ((i+1)%m)*n+(j+1)%n, ((i+1)%m)*n+j });
        normals.push({cosph*costh,sinph,cosph*sinth});
      }
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }
  func plane():AbstractMesh{
    vertices:=list[vec[f32,3]]{
      {-1.,0,-1},{-1.,0,1},{1.,0,1},{1.,0,-1}
    };
    faces:=list[list[i32]]{list[i32]{0,1,2,3}};
    normals:=list[vec[f32,3]]{
      {0.,1,0},{0.,1,0},{0.,1,0},{0.,1,0}
    }
    return AbstractMesh{
      vertices:vertices,faces:faces,normals:normals
    };
  }

}


W := 720
H := 720
context := win.init(W,H,win.CONTEXT_3D);
g3d.init(context);
frag.init(context);

shader0 := frag.program(embed(func(@varying normal:vec[f32,3]):vec[f32,4]{
  c := normal*0.5+0.5;
  return {c.x,c.y,c.z,1.0};
}) as "fragment");

meshes := list[g3d.Mesh]{
  prim.cube().faceted(),
  prim.cube().wireframe(),
  prim.uvsphere(5,10).faceted(),
  prim.uvsphere(10,20).faceted(),
  prim.uvsphere(10,20).smooth(),
  prim.uvsphere(10,20).wireframe(),
  prim.icosphere(0).faceted(),
  prim.icosphere(0).wireframe(),
  prim.icosphere(1).faceted(),
  prim.icosphere(1).wireframe(),
  prim.icosphere(2).faceted(),
  prim.icosphere(2).wireframe(),
  prim.icosphere(3).smooth(),
  prim.icosphere(3).wireframe(),
  prim.cylinder(10).faceted(),
  prim.cylinder(20).smooth(),
  prim.cylinder(10).wireframe(),
  prim.cone(10).faceted(),
  prim.cone(20).smooth(),
  prim.cone(10).wireframe(),
  prim.torus(0.5,20,20).faceted(),
  prim.torus(0.5,20,20).smooth(),
  prim.torus(0.5,20,20).wireframe(),
  prim.plane().smooth(),
  prim.plane().wireframe()
};

cam := g3d.Camera{}
cam.perspective(45,W/(H as f32),0.1,100.0);
cam.look_at({0,0,16},{0,0,0},g3d.AXIS_Y);

frame := 0;
while (1){
  time.fps(60);
  g3d.background(0.1)

  frag.begin(shader0);
  cam.begin();
  for (i := 0; i < meshes.length(); i++){
    model :=g3d.mat.translate((i%5)*2.4-4.8,4.8-(i/5)*2.4,0)@*
            g3d.mat.rotate_deg(g3d.AXIS_Y,frame*2)@*
            g3d.mat.rotate_deg(g3d.AXIS_X,frame*1);
    meshes[i].draw(model)
  }
  cam.end();
  frag.end();

  g3d.flush();
  win.poll();
  frame++;
}