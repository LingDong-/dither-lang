include "std/frag"
include "std/win"
include "std/math"
include "std/io"
// an example showcasing code-sharing between shader and CPU code
// -- learn one language, write your code once
resolution := {640.0,480.0};
t : f32;
image : frag.Texture; // == sampler2D in GLSL, fbo in OpenGL

frag.init(win.init(...resolution,win.CONTEXT_3D));
// define a function for the entry point of first shader,
// just like writing a normal function in dither.
func pass0(@varying uv:vec[f32,2]):vec[f32,4]{
  return {uv.x,uv.y,0.5,1.0};
}
// required helper functions are crawled and included in glsl
// compilation automatically
func offset(p:vec[f32,2]):vec[f32,2]{
  return {0.0, math.cos(p.x*12.0)*math.sin(p.y*3.14)}*0.1;
}
// dither function for second shader, which uses the helper function
// xyz.sample(...) is compiled to texture2D(xyz,...)
func pass1(
  @uniform image:frag.Texture,
  @varying uv:vec[f32,2],
  @uniform t:f32
):vec[f32,4]{
  color := image.sample(uv+offset(uv+{t,0.0}));
  return {color.r, color.g, math.sin(t)*0.2+0.5, 1.0};
}
// you can call these shader functions in CPU too!
// great for sanity checks...
io.println(pass0({0.5,0.5}));

// use the "embed" statement to generate a fragment shader
// from an entry point -- the result is a string containing
// a valid GLSL program. Then use frag library function to
// compile and link the shader.
shader0 := frag.program(embed pass0 as "fragment");
shader1 := frag.program(embed pass1 as "fragment");

image = frag.texture(...resolution);
t = 0;
while (1){
  frag.begin(shader0,image); // rendering shader0 onto image
  frag.render();
  frag.end();
  
  frag.begin(shader1); // rendering shader1 onto main screen
  frag.uniform("t", t+=0.0005); 
  frag.uniform("image", image); // put in the output of the first pass
  frag.render();
  frag.end();
  
  win.poll(); // display & read windowing events
}