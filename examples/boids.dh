include "std/math"
include "std/list"
include "std/vec"
include "std/gx"

width := 300
height := 300

// Based on https://processing.org/examples/flocking.html
// The Boid class
typedef Boid = {
  
  position : vec[f32,2] = {0.0,0.0};
  velocity : vec[f32,2] = {0.0,0.0};
  acceleration:vec[f32,2] = {0.0,0.0};
  r : f32 = 2.0;
  maxforce : f32 = 0.03;  // Maximum steering force
  maxspeed : f32 = 2.0;   // Maximum speed
  
  func init(x:f32,y:f32){
    angle := math.random()*math.pi*2;
    .velocity = {math.cos(angle),math.sin(angle)};
    .position = {x,y};
  }
  // Separation
  // Method checks for nearby boids and steers away
  func separate(boids:list[Boid]) : vec[f32,2]{
    desiredseparation := 25.0;
    steer := {0.0, 0.0};
    count := 0;
    // For every boid in the system, check if it's too close
    for (i:=0; i < boids.length(); i++) {
      other := boids[i];
      d := (.position-other.position).mag();
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if (d > 0 && d < desiredseparation) {
        // Calculate vector pointing away from neighbor
        diff := .position - other.position;
        diff = diff.dir()/d;
        steer += diff;
        count++;            // Keep track of how many
      }
    }
    // Average -- divide by how many
    if (count > 0) {
      steer /= count;
    }
    // As long as the vector is greater than 0
    if (steer.mag() > 0) {
      // Implement Reynolds: Steering = Desired - Velocity
      steer = steer.dir()*.maxspeed-.velocity
      steer *= math.min(1, .maxforce/steer.mag());
    }
    return steer;
  }

  // Alignment
  // For every nearby boid in the system, calculate the average velocity
  func align (boids:list[Boid]) : vec[f32,2]{
    neighbordist := 50.0;
    sum := {0.0, 0.0};
    count := 0;
    for (i:=0; i < boids.length(); i++) {
      other := boids[i];
      d := (.position-other.position).mag();
      if (d > 0 && d < neighbordist) {
        sum += other.velocity;
        count++;
      }
    }
    if (count) {
      sum /= count;

      // Implement Reynolds: Steering = Desired - Velocity
      sum = sum.dir()*.maxspeed;

      steer := sum-.velocity;
      steer *= math.min(1, .maxforce/steer.mag());
      return steer;
    } else {
      return {0.0, 0.0};
    }
  }
  // A method that calculates and applies a steering force towards a target
  // STEER = DESIRED MINUS VELOCITY
  func seek(target:vec[f32,2]) : vec[f32,2] {
    desired := target-.position;  // A vector pointing from the position to the target
    // Scale to maximum speed
    desired = desired.dir() * .maxspeed;

    // Steering = Desired minus Velocity
    steer := desired-.velocity;
    steer *= math.min(1, .maxforce/steer.mag());
    return steer;
  }
  // Cohesion
  // For the average position (i.e. center) of all nearby boids, calculate steering vector towards that position
  func cohesion (boids:list[Boid]) : vec[f32,2] {
    neighbordist := 50.0;
    sum := {0.0, 0.0};   // Start with empty vector to accumulate all positions
    count := 0;
    for (i:=0; i < boids.length(); i++) {
      other := boids[i];
      d := (.position-other.position).mag();
      if (d > 0 && d < neighbordist) {
        sum += other.position; // Add position
        count++;
      }
    }
    if (count) {
      sum /= count;
      return .seek(sum);  // Steer towards the position
    } else {
      return {0.0,0.0};
    }
  }
  
  // We accumulate a new acceleration each time based on three rules
  func flock(boids:list[Boid]){
    sep := .separate(boids); // Separation
    ali := .align(boids);    // Alignment
    coh := .cohesion(boids); // Cohesion
    // Arbitrarily weight these forces
    // Add the force vectors to acceleration
    .acceleration += sep*1.5;
    .acceleration += ali*1.0;
    .acceleration += coh*1.0;
  }
  // Method to update position
  func update(){
    .velocity += .acceleration;
    .velocity *= math.min(1, .maxspeed/.velocity.mag());
    .position += .velocity;
    .acceleration *= 0.0;
  }
  func borders(width:f32,height:f32) {
    if (.position.x < -.r) .position = {width+.r,.position.y};
    if (.position.y < -.r) .position = {.position.x,height+.r};
    if (.position.x > width+.r)  .position = {-.r, .position.y};
    if (.position.y > height+.r) .position = {.position.x,-.r};
  }
}


boids := list[Boid]{};
gx.size(width,height);
for (i := 0; i < 20; i++){
  b := Boid{};
  b.init(width/2,height/2);
  boids.push(b);
}

while (1){
  gx.background(0.2);
  
  for (i := 0; i < boids.length(); i++){
    b := boids[i];
    
    b.flock(boids);
    b.update();
    b.borders(width,height);
    
    theta := math.atan2(...b.velocity.yx);
    gx.fill(0.5);
    gx.stroke(1.0);
    gx.push_matrix();
    gx.translate(...b.position);
    gx.rotate_deg(theta*180/math.pi+90);
    gx.begin_shape();
    gx.vertex(0, -b.r*2);
    gx.vertex(-b.r, b.r*2);
    gx.vertex(b.r, b.r*2);
    gx.end_shape(1);
    gx.pop_matrix();
  }
  

  e := gx.poll();
  if (e.type == gx.MOUSE_PRESSED){
    b := Boid{};
    b.init(e.x, e.y);
    boids.push(b);
  }


}


