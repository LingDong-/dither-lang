include "std/math"
include "std/vec"
include "std/io"
include "std/gx"
include "std/frag"
include "std/win"

USE_GPU := 1;
USE_CPU := !USE_GPU;

W := 320;
H := 240;

func ellipsoid(p:vec[f32,3],r:vec[f32,3]):f32{
  x := p.x/r.x;
  y := p.y/r.y;
  z := p.z/r.z;
  k0 := math.sqrt(x*x+y*y+z*z);
  x = p.x/(r.x*r.x);
  y = p.y/(r.y*r.y);
  z = p.z/(r.z*r.z);
  k1 := math.sqrt(x*x+y*y+z*z);
  return k0*(k0-1.0)/k1;
}

func torus_z(p:vec[f32,3],tx:f32,ty:f32):f32{
  qx := math.sqrt(p.x*p.x+p.y*p.y)-tx;
  return math.sqrt(qx*qx+p.z*p.z)-ty;
}

func cylinder(p:vec[f32,3],h:f32,r:f32):f32{
  dx := math.abs(math.sqrt(p.x*p.x+p.z*p.z))-r;
  dy := math.abs(p.y)-h;
  o := math.min(math.max(dx,dy),0.0);
  dx = math.max(dx,0.);
  dy = math.max(dy,0.);
  return o + math.sqrt(dx*dx+dy*dy);
}

func cone(p:vec[f32,3], cx:f32, cy:f32, h:f32 ):f32{
  q := math.sqrt(p.x*p.x+p.z*p.z);
  return math.max(cx * q + cy * p.y, -h-p.y);
}

func cone_usd(p:vec[f32,3], cx:f32, cy:f32, h:f32 ):f32{
  q := math.sqrt(p.x*p.x+p.z*p.z);
  return math.max(cx * q - cy * p.y, -h+p.y);
}

func op_union(d1:f32,d2:f32):f32{
  return math.min(d1,d2);
}
func op_subtract(d1:f32,d2:f32):f32{
  if (d1 > -d2){
    return d1;
  }else{
    return -d2;
  }
}
func op_intersect(d1:f32,d2:f32):f32{
  return math.max(d1,d2);
}

func op_smooth_union(d1:f32,d2:f32,k:f32):f32{
  h := 0.5 + 0.5*(d2-d1)/k;
  if (h > 1.) h = 1.;
  if (h < 0.) h = 0.;
  return d2 * (1-h) + d1 * h - k*h*(1.0-h);
}


func scene(p:vec[f32,3]):f32{
  rx := (p.x-0.65)*0.707-(p.y-0.32)*0.707;
  ry := (p.x-0.65)*0.707+(p.y-0.32)*0.707;
  return op_union(
    op_smooth_union(
      op_smooth_union(
        torus_z({p.x+0.45,p.y+0.04,p.z},0.18,0.05),
        op_smooth_union(
          ellipsoid({p.x,p.y+0.1,p.z},{0.45,0.25,0.45}),
          cylinder(p,0.25,0.3),
          0.2
        ),
        0.1
      ),
      op_subtract(cone({rx,ry,p.z},24.0/25,7.0/25,0.8),-p.y+0.25),
      0.1
    ),
    op_smooth_union(
      ellipsoid({p.x,p.y-0.25,p.z},{0.26,0.1,0.26}),
      cone_usd({p.x,p.y-0.36,p.z},0.707,0.707,0.06),
      0.07
    )
  );
}

func cast_ray(ro:vec[f32,3],rd:vec[f32,3]):f32{
  ow : f32;
  t := 0.0;
  tmax := 100.0;
  for (i:=0; i<100; i++){
    if (t>=tmax) break;
    hw := scene(ro + rd * t);
    ow = t;
    if(hw<0.0001*t){
      break;
    }
    t += hw;
  }
  if (t > tmax){
    ow = -1.;
  }
  return ow;
}

func calc_normal(p:vec[f32,3]):vec[f32,3]{
  ex := 0.00028865;
  ey :=-0.00028865;
  w0 := scene(p+{ex,ey,ey});
  w1 := scene(p+{ey,ey,ex});
  w2 := scene(p+{ey,ex,ey});
  w3 := scene(p+{ex,ex,ex});
  return ({
    ex * w0 + ey * w1 + ey * w2 + ex * w3, 
    ey * w0 + ey * w1 + ex * w2 + ex * w3,
    ey * w0 + ex * w1 + ey * w2 + ex * w3,
  }).dir();
}

func render(ro:vec[f32,3],rd:vec[f32,3]):f32{
  tw := cast_ray(ro,rd);
  if (tw < 0.){
    return 0.01;
  }
  p := ro + tw * rd;
  n := calc_normal(p);
  l := {-0.4,0.5,0.0}.dir();
  d := n.dot(l);
  d = (d+1.)*0.5
  return d;
}

ro := {0.,0.5,1.0}
ta := {0.,0.,0.}

cw := (ta-ro).dir();
cu := cw.cross({0.,1.,0.}).dir();
cv := cu.cross(cw);

if (USE_CPU){
  gx.size(W,H);
  pg := gx.create_graphics(W,H);
  idx := 0;
  chunk := 64;
  while (1){
    if (idx < W*H){
      pg.begin();
      for (k := idx; k < idx+chunk; k++){
        if (k >= W*H) break;
        i := k / W;
        j := k % W;
        px := (-W+2*j)/(H as f32) 
        py := ( H-2*i)/(H as f32) 
        rd := ({
          px * cu.x + py * cv.x + cw.x * 2,
          px * cu.y + py * cv.y + cw.y * 2,
          px * cu.z + py * cv.z + cw.z * 2,
        }).dir();
        c := render(ro,rd);
        gx.stroke(c);
        gx.point(j,i);
      }
      idx += chunk;
      pg.end();
    }
    gx.background(0.5);
    pg.draw(0,0);
    gx.poll();
  }
}

if (USE_GPU){
  frag.init(win.init(W,H,win.CONTEXT_3D));
  shader := frag.program(embed(func(
    @builtin frag_coord : vec[f32,4],
    @uniform cw : vec[f32,3],
    @uniform cu : vec[f32,3],
    @uniform cv : vec[f32,3],
  ):vec[f32,4]{
    px := (-W+2* frag_coord.x)/(H as f32) 
    py := (-H+2* frag_coord.y)/(H as f32) 
    rd := ({
      px * cu.x + py * cv.x + cw.x * 2.,
      px * cu.y + py * cv.y + cw.y * 2.,
      px * cu.z + py * cv.z + cw.z * 2.,
    }).dir();
    c := render(ro,rd);
    return {c,c,c,1.0};
  }) as "fragment")

  while (1){
    frag.begin(shader);
    frag.uniform("cw",cw);
    frag.uniform("cu",cu);
    frag.uniform("cv",cv);
    frag.render();
    frag.end();
    win.poll();
  }

}



