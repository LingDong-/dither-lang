include "std/g3d"
include "std/frag"
include "std/win"
include "std/list"
include "std/arr"
include "std/time"
include "std/vec"
include "std/math"
include "std/img"
include "std/io"

W := 512;
H := 512;

context := win.init(W,H,win.CONTEXT_3D);
g3d.init(context);
frag.init(context);

func cylinder(sides:i32):g3d.Mesh{
  vertices:=list[vec[f32,3]]{};
  faces:=list[list[i32]]{ list[i32]{}, list[i32]{} };
  normals:=list[vec[f32,3]]{};
  for (i := 0; i < sides; i++){
    a := i*math.PI*2./sides;
    x := math.cos(a);
    z := math.sin(a);
    vertices.push({x,-1,z});
    vertices.push({x,-1,z});
    vertices.push({x, 1,z});
    vertices.push({x, 1,z});
    normals.push({0,-1,0});
    normals.push({x,0,z});
    normals.push({0,1,0});
    normals.push({x,0,z});
    faces[0].push(i*4  );
    faces[1].insert(0,i*4+2);
    faces.push(list[i32]{i*4+1,i*4+3,((i+1)%sides)*4+3,((i+1)%sides)*4+1});
  }
  mesh := g3d.Mesh{vertices:vertices,normals:normals}
  for (i := 0; i < faces.length(); i++) {
    n := faces[i].length();
    for (j := 0; j < n; j++){
      mesh.indices.push(faces[i][0]);
      mesh.indices.push(faces[i][j-1]);
      mesh.indices.push(faces[i][j]);
    }
  }
  return mesh;
}

cy := cylinder(32);

shader0 := frag.program(embed(func(
  @varying normal:vec[f32,3],
  @varying uv:vec[f32,2],
  @varying position:vec[f32,3],
  @uniform shadow_map:frag.Texture,
  @uniform shadow_matrix:vec[f32,4,4],
  @uniform ld:vec[f32,3]
):vec[f32,4]{
  ndl := normal.dot(ld);
  bias := math.min(math.max(0.008*math.tan(math.acos(ndl)),0.0),0.01);

  shadow_coord := (shadow_matrix @* {position.x,position.y,position.z,1.0}).xyzw;
  sh := (shadow_coord.xyz/shadow_coord.w)*0.5+0.5;
  lam := math.max(ndl,0.0)*0.5+0.5;
  c := {lam,lam,lam}
  samp := 1.0;
  for (i:=-2; i<=2; i++){
    for (j:=-2; j<=2; j++){
      if (shadow_map.sample(sh.xy+{(i as f32),j}*0.001).x<sh.z-bias){
        samp -= 0.03;
      }
    }
  }
  c *= samp;
  return {c.x,c.y,c.z,1.0};
}) as "fragment");

shader1 := frag.program(embed(func(
  @builtin frag_coord:vec[f32,4],
  @varying normal:vec[f32,3]
):vec[f32,4]{
  c := frag_coord.z;
  return {c,c,c,1.0};
}) as "fragment");


cam := g3d.Camera{};
cam.look_at({-7,7,-7},{0,0,0},g3d.AXIS_Y);
cam.perspective(60,W/(H as f32),0.1,100.0);

shadow := frag.texture(512,512);

frame := 0;

cy := cylinder(32);

func draw_scene(){
  cy.draw(g3d.mat.translate(0,-1,0) @* 
          g3d.mat.scale(5.5,1,5.5));
  for (i := 0; i < 4; i++){
    for (j : = 0; j < 4; j++){
      h := (i*0.7+j*0.5)*0.7+0.2;
      cy.draw(g3d.mat.translate(i*2.0-3,h,j*2.0-3) @*
              g3d.mat.scale(0.6,h,0.6));
    }
  }
}

while (1){
  time.fps(120);

  ang := frame*0.05;
  ld := ({math.cos(ang),0.5,math.sin(ang)}).dir();
  light := g3d.Camera{};
  light.look_at(ld,{0.,0,0},g3d.AXIS_Y);
  light.ortho(-8,8,-8,8,-10,20);

  frag.begin(shader1,shadow);
  g3d.background(0.0);
  light.begin();
  draw_scene();
  light.end();
  frag.end();

  frag.begin(shader0);
  g3d.background(0.);
  frag.uniform("shadow_map",shadow);

  shadow_matrix := light.proj@*light.view;
  frag.uniform("shadow_matrix",shadow_matrix);
  frag.uniform("ld",ld);
  cam.begin();
  draw_scene();
  cam.end();
  frag.end();

  e := win.poll();
  frame++;
}
